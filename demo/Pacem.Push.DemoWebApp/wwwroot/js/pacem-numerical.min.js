/**
 * pacem v0.10.0 (https://js.pacem.it)
 * Copyright 2020 Pacem (https://pacem.it)
 * Licensed under MIT
 */
var Pacem;!function(t){!function(e){!function(e){e.Vector=class Vector{static unit(t){const e={x:t.x,y:t.y};return this.normalize(e),e}static normalize(t){const e=Math.sqrt(t.x*t.x+t.y*t.y);if(e<=0)throw"Cannot normalize a vector of length 0.";const r=1/e;t.x*=r,t.y*=r}static from(e,r){return t.Point.subtract(e,r)}static dot(t,e){return t.x*e.x+t.y*e.y}static cross(t,e){return t.x*e.y-t.y*e.x}}}(e.LinearAlgebra||(e.LinearAlgebra={}))}(t.Geometry||(t.Geometry={}))}(Pacem||(Pacem={})),function(t){!function(e){const r=180/Math.PI,n=2*Math.PI,i=e.LinearAlgebra.Vector;function a(t){return null!=t&&"x"in t&&"number"==typeof t.x&&"y"in t&&"number"==typeof t.y}e.Utils=class Utils{static slopeRad(t,e){return Math.atan2(e.y-t.y,e.x-t.x)}static slopeRad2(t,e){return(n+this.slopeRad(t,e))%n}static slopeDeg(t,e){return this.slopeRad(t,e)*r}static slopeDeg2(t,e){return(360+this.slopeDeg(t,e))%360}static intersect(t,e,...r){return Array.isArray(t)&&Array.isArray(e)?this._intersectSegments(t,e,!0):this._intersectRects.apply(this,arguments)}static intersectLines(t,e,r,n){let i,a;return Array.isArray(t)&&Array.isArray(e)&&2===t.length&&2===e.length&&"number"==typeof t[0]&&"number"==typeof e[0]&&"number"==typeof t[1]&&"number"==typeof e[1]&&(r=e[0],n=e[1],e=t[1],t=t[0]),"number"==typeof t&&"number"==typeof e?(i=[{x:0,y:e},{x:1,y:t+e}],a=[{x:0,y:n},{x:1,y:r+n}]):(i=t,a=e),this._intersectSegments(i,a,!1)}static cramer(t,e){Array.isArray(t)&&(t={a:t[0],b:t[1],c:t[2]}),Array.isArray(e)&&(e={a:e[0],b:e[1],c:e[2]});let r=(t.b*e.c-t.c*e.b)/(t.b*e.a-t.a*e.b),n=(t.c*e.a-t.a*e.c)/(t.b*e.a-t.a*e.b);return{x:-r.roundoff(),y:-n.roundoff()}}static mq(t,e){let r;if(a(t)?r=t:(r=t[0],e=t[1]),r.x===e.x)return[Number.NaN,Number.NaN];const n=(e.y-r.y)/(e.x-r.x);return[n,r.y-n*r.x]}static _intersectSegments(t,e,r){const n=t[0],i=t[1],a=e[0],s=e[1],c=Math.min(n.x,i.x),u=Math.min(n.y,i.y),o=Math.max(n.x,i.x),l=o-c,m=Math.max(n.y,i.y),h=m-u,y=Math.min(a.x,s.x),f=Math.min(a.y,s.y),x=Math.max(a.x,s.x),p=x-y,g=Math.max(a.y,s.y),b=g-f;if(0===l&&0===p)return null;if(0===h&&0===b)return null;const M=t=>t.x<y||t.x>x||t.x<c||t.x>o,d=t=>t.y<f||t.y>g||t.y<u||t.y>m;var P=null;if(0===l){if(r&&(y>c||x<o))return null;const t=this.mq(a,s);P=this.cramer([1,0,-c],[t[0],-1,t[1]]),r&&d(P)&&(P=null)}else if(0===p){if(r&&(c>y||o<x))return null;const t=this.mq(n,i);P=this.cramer([t[0],-1,t[1]],[1,0,-y]),r&&d(P)&&(P=null)}else if(0===h){if(r&&(f>u||g<m))return null;const t=this.mq(a,s);P=this.cramer([0,1,-u],[t[0],-1,t[1]]),r&&M(P)&&(P=null)}else if(0===b){if(r&&(u>f||m<g))return null;const t=this.mq(n,i);P=this.cramer([t[0],-1,t[1]],[0,1,-f]),r&&M(P)&&(P=null)}else{let t;if(!r||(t=this._intersectRects({x:c,y:u,width:l,height:h},{x:y,y:f,width:p,height:b}))&&t.width>0&&t.height>0){const e=this.mq(n,i),c=this.mq(a,s),u=e[0],o=c[0],l=e[1],m=c[1];if(u!==o){let e=(P=this.cramer([u,-1,l],[o,-1,m])).x,n=P.y;r&&(e<t.x||e>t.x+t.width||n<t.y||n>t.y+t.height)&&(P=null)}}}return null===P?null:{x:P.x,y:P.y}}static _intersectRects(...e){return t.Rect.intersect.apply(this,e)}static dot(t,e){return i.dot(t,e)}static cross(t,e){return i.cross(t,e)}static distance(e,r){if(null!=(n=e)&&Array.isArray(n)&&2===n.length&&a(n[0])&&a(n[1]))return t.Point.distance(e[0],e[1]);if(a(r))return t.Point.distance(e,r);{const t=r[0],n=r[1];return Math.abs(t*e.x-e.y+n)/Math.sqrt(Math.pow(t,2)+1)}var n}static inLine(t,e){const r=i.from(e[0],t),n=i.from(t,e[1]);return this.cross(r,n).isCloseTo(0)}static inSegment(t,e){const r=Math.min(e[0].x,e[1].x),n=Math.max(e[0].x,e[1].x),i=Math.min(e[0].y,e[1].y),a=Math.max(e[0].y,e[1].y);return t.x>=r&&t.x<=n&&t.y>=i&&t.y<=a&&this.inLine(t,e)}static inTriangle(e,r){let n;for(let i=0;i<3;i++){const a=r[i],s=r[(i+1)%3],c=t.Point.subtract(s,e),u=t.Point.subtract(a,e),o=this.cross(c,u);if(i>0&&o*n<=0)return!1;n=o}return!0}static inPolygon(t,e){if(!((null==e?void 0:e.length)>=3))throw"Not enough vertices";const r=e.length;if(3===r)return this.inTriangle(t,[e[0],e[1],e[2]]);let n=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=0,s=0;for(let t=0;t<r;t++){const r=e[t];n=Math.min(n,r.x),i=Math.min(i,r.y),a=Math.max(a,r.x),s=Math.max(s,r.y)}if(t.x<n||t.x>a||t.y<i||t.y>s)return!1;const c=[{x:n-1,y:t.y},t];let u=0;for(let n=0;n<r;n++){const i=e[n],a=e[(n+1)%r],s=[i,a];if(i.y===t.y){const s=e[(n-1+r)%r];t.x>i.x&&(s.y-t.y)*(a.y-t.y)<0&&u++}else{if(a.y===t.y)continue;null!=this.intersect(s,c)&&u++}}return u%2==1}}}(t.Geometry||(t.Geometry={}))}(Pacem||(Pacem={})),function(t){!function(t){function e(t){return"number"==typeof t&&(t={real:t,img:0}),t}var r;function n(t,e){const r={};return Object.defineProperty(r,"real",{value:t,writable:!1}),Object.defineProperty(r,"img",{value:e,writable:!1}),r}function i(){return r||(r=n(Number.NaN,Number.NaN))}t.Complex=class Complex{static build(t,e){return this.isComplex(t)?t:n(t,e||0)}static add(t,r){const i=e(t),a=e(r);return n(i.real+a.real,i.img+a.img)}static subtract(t,r){const i=e(t),a=e(r);return n(i.real-a.real,i.img-a.img)}static multiply(t,r){const i=e(t),a=e(r);return n(i.real*a.real-i.img*a.img,i.real*a.img+i.img*a.real)}static divide(t,r){const a=e(t),s=e(r),c=this.absSquare(s).roundoff();if(0===c)return i();const u=1/c;return n(u*(a.real*s.real+a.img*s.img),u*(a.img*s.real-a.real*s.img))}static absSquare(t){const r=e(t);return Math.pow(r.real,2)+Math.pow(r.img,2)}static modulus(t){return Math.sqrt(this.absSquare(t))}static isComplex(t){return null!=t&&"object"==typeof t&&"real"in t&&"img"in t&&"number"==typeof t.real&&"number"==typeof t.img}static conjugate(t){return n((t=e(t)).real,0==Math.abs(t.img)?0:-t.img)}static get NaC(){return i()}}}(t.Mathematics||(t.Mathematics={}))}(Pacem||(Pacem={})),function(t){!function(t){!function(e){const r={};function n(e,n){const i=r[n]=r[n]||{};return i[e]=i[e]||function(e,r){const n=2*Math.PI*e/r;return t.Complex.build(Math.cos(n),Math.sin(n))}(e,n)}e.Fourier=class Fourier{static transform(t,e=!0){return(r=(t=t||[]).length)>0&&0==(r&r-1)?this.fft(t,e):this.dft(t,e);var r}static invert(t,e=!0){return this.idft(t||[],e)}static dft(e,r=!0){var i;const a=null===(i=e||[])||void 0===i?void 0:i.length,s=r?1/Math.sqrt(a):1,c=[];for(let r=0;r<a;r++){c.push({real:0,img:0});for(let i=0;i<a;i++){const u=n(r*i,a),o=t.Complex.multiply(e[i],u),l=t.Complex.multiply(o,s);c[r]=t.Complex.add(c[r],l)}}return c}static idft(e,r=!0){const n=e.map(e=>t.Complex.build(e.img,e.real));return this.transform(n,r).map(e=>t.Complex.build(e.img,e.real))}static fft(e,r=!0){const i=function e(r){const i=[],a=r.length;if(1===a)return[t.Complex.build(r[0])];const s=e(r.filter((t,e)=>e%2==0)),c=e(r.filter((t,e)=>e%2==1));for(var u=0;u<a/2;u++){const e=s[u],r=t.Complex.multiply(n(u,a),c[u]);i[u]=t.Complex.add(e,r),i[u+a/2]=t.Complex.subtract(e,r)}return i}(e);if(!r)return i;const a=1/Math.sqrt(e.length);return i.map(e=>t.Complex.multiply(e,a))}}}(t.DataAnalysis||(t.DataAnalysis={}))}(t.Mathematics||(t.Mathematics={}))}(Pacem||(Pacem={})),function(t){!function(t){!function(t){const e=Math.sqrt(Math.PI),r=function(t){let e,r,n;return n=(e=1/(1+.5*(r=Math.abs(t))))*Math.exp(-r*r-1.26551223+e*(1.00002368+e*(.37409196+e*(.09678418+e*(e*(.27886807+e*(e*(1.48851587+e*(.17087277*e-.82215223))-1.13520398))-.18628806))))),t>=0?n:2-n};class Gaussian{constructor(t,e){this.mean=t,this.stdev=Math.abs(e),this.variance=Math.pow(e,2)}static get normal(){return n}probabilityDensity(t){const r=this.stdev*Math.SQRT2*e;return Math.exp(-.5*Math.pow(this._z(t),2))/r}_z(t){return(t-this.mean)/this.stdev}probability(t){return.5*r(-this._z(t)/Math.SQRT2)}}t.Gaussian=Gaussian;const n=new Gaussian(0,1)}(t.DataAnalysis||(t.DataAnalysis={}))}(t.Mathematics||(t.Mathematics={}))}(Pacem||(Pacem={})),function(t){!function(t){!function(t){t.Utils=class Utils{static lcd(...t){if(t.length<=1)throw"Insufficient set of numbers.";function e(t,e){return t*e/function t(e,r){return r?t(r,e%r):0===r?e:NaN}(t,e)}let r=t[0];for(let n=1;n<t.length;n++)r=e(r,t[n]);return r}}}(t.NumberTheory||(t.NumberTheory={}))}(t.Mathematics||(t.Mathematics={}))}(Pacem||(Pacem={})),function(t){!function(t){!function(t){function e(t,e=!1){const r=this._varNum(t);return Math.sqrt(r/(t.length+(e?1:0)))}t.Utils=class Utils{static sum(t){return t.reduce((t,e)=>t+e,0)}static mean(t){return this.sum(t)/t.length}static var(t){return function(t){const e=this.mean(t);return t.reduce((t,r)=>Math.pow(r-e,2)+t,0)}(t)/t.length}static pstdev(t){return e(t,!1)}static sstdev(t){return e(t,!0)}static gaussian(e,r){return new t.Gaussian(e,r)}}}(t.DataAnalysis||(t.DataAnalysis={}))}(t.Mathematics||(t.Mathematics={}))}(Pacem||(Pacem={}));